/* This code was AUTOMATICALLY generated.
 * --> EDIT WITH CARE! <--
 */

/**
 * @file periodic_sporadic.c
 * @author TimesTool, Version 1.3 beta, April, 2007 (build 2461) <www.timestool.com>
 * @brief Generated by: User
 * @date Thu May 06 15:08:42 CEST 2021
 * - with Target:          brickos
 * 
 */

#include "periodic_sporadic.h"
#include "brickos_interface.h"
#include "periodic_sporadic_global.h"
#include "periodic_sporadic_init.h"
/**
 * @name Task identifiers (tid).
 */
#define tid_offset 200
#define tid_task_a tid_offset+0
#define tid_task_b tid_offset+1
#define tid_NOP tid_offset+2

/**
 * Location identifiers, also offsets into
 * location array.
 */
#define Process_A_Location_1 0
#define Process_A_Location_2 2
#define Process_B_Location_1 4
#define Process_B_Location_2 6
#define PERIODIC_TASKS_START 8

char release_list[NB_TASK]={ 0,0,0,0,0};


wakeup_t task_release(wakeup_t data) {
  if(release_list[data]) {
    switch (data) { 
    default: return true;
  }
  } else
  return false;
}

wakeup_t task_complete(wakeup_t tid) {
  switch(tid) { 
  case 0:case 1:}
  return true;
}

/**
 * Constant values
 */

/**
 * Clock variables
 * Ordered: global first, then local clocks for each process.
 */
time_t clock_Process_A_x1;
time_t clock_Process_B_x1;
time_t clock_PERIODIC_TASKS_x;
/**
 * Integer variables
 */
int PERIODIC_TASKS_t_task1=0;
int PERIODIC_TASKS_t_task2=0;
int PERIODIC_TASKS_t_task3=0;
int* IVARS[NB_VAR] ={&PERIODIC_TASKS_t_task1,&PERIODIC_TASKS_t_task2,&PERIODIC_TASKS_t_task3};

void COPY2LOCAL( int tid, int instance ) {
  switch( tid ) {
  }
};

/**
 * Evaluate guards on transition trn.
 * @param trn Transition id
 * @return true if guard satisfied, false otherwise.
 */
bool eval_guard(int trn) {
  switch(trn) {
  case 0: return (rdClock(Process_A_x1)>=13);
  case 2: return (rdClock(Process_B_x1)>=21);
  case 4: return (rdClock(PERIODIC_TASKS_x)==PERIODIC_TASKS_t_task1);
  case 5: return (rdClock(PERIODIC_TASKS_x)==PERIODIC_TASKS_t_task2);
  case 6: return (rdClock(PERIODIC_TASKS_x)==PERIODIC_TASKS_t_task3);
  case 1:
  case 3:
    return true;
  }
  return false;
}

/**
 * Perform assignments on transition trn.
 * @param trn Transition id.
 */
void assign(int trn) {
  switch(trn) {
  case 1: 
    setClock(Process_A_x1,0); break;
  case 3: 
    setClock(Process_B_x1,0); break;
  case 4: 
    setClock(PERIODIC_TASKS_x,0);
    PERIODIC_TASKS_t_task2=PERIODIC_TASKS_t_task2-PERIODIC_TASKS_t_task1;
    PERIODIC_TASKS_t_task3=PERIODIC_TASKS_t_task3-PERIODIC_TASKS_t_task1;
    PERIODIC_TASKS_t_task1=15; break;
  case 5: 
    setClock(PERIODIC_TASKS_x,0);
    PERIODIC_TASKS_t_task1=PERIODIC_TASKS_t_task1-PERIODIC_TASKS_t_task2;
    PERIODIC_TASKS_t_task3=PERIODIC_TASKS_t_task3-PERIODIC_TASKS_t_task2;
    PERIODIC_TASKS_t_task2=20; break;
  case 6: 
    setClock(PERIODIC_TASKS_x,0);
    PERIODIC_TASKS_t_task1=PERIODIC_TASKS_t_task1-PERIODIC_TASKS_t_task3;
    PERIODIC_TASKS_t_task2=PERIODIC_TASKS_t_task2-PERIODIC_TASKS_t_task3;
    PERIODIC_TASKS_t_task3=30; break;

  }
}

/**
 * Transition table.
 */
trans_t TRANS[NB_TRANS] = {
  {true,Process_A_Location_1,Process_A_Location_2,-1},
  {false,Process_A_Location_2,Process_A_Location_1,-1},
  {true,Process_B_Location_1,Process_B_Location_2,-1},
  {false,Process_B_Location_2,Process_B_Location_1,-1},
  {true,PERIODIC_TASKS_START,PERIODIC_TASKS_START,-1},
  {true,PERIODIC_TASKS_START,PERIODIC_TASKS_START,-1},
  {true,PERIODIC_TASKS_START,PERIODIC_TASKS_START,-1}
};

/**
 * Location list
 */
loc_t LOC[NB_TRANS+NB_LOC] = {
  0,tid_NOP/*Location_1*/,
  1,tid_task_a/*Location_2*/,
  2,tid_NOP/*Location_1*/,
  3,tid_task_b/*Location_2*/,
  4,5,6,tid_NOP/*START*/
};

/**
 * Task bodies
 */
//
//
int task_a() {
  TASK_BEGIN(task_a)
// No code pointer for this task

  TASK_END(task_a)
}

//
//
int task_b() {
  TASK_BEGIN(task_b)
// No code pointer for this task

  TASK_END(task_b)
}

//
//
int task1() {
  TASK_BEGIN(task1)
// No code pointer for this task

  TASK_END(task1)
}

//
//
int task2() {
  TASK_BEGIN(task2)
// No code pointer for this task

  TASK_END(task2)
}

//
//
int task3() {
  TASK_BEGIN(task3)
// No code pointer for this task

  TASK_END(task3)
}

int main(int argc, char **argv) {

  periodic_sporadic_init();

  execi( &task_a, 0, NULL, 5, SMALL_STACK_SIZE);
  execi( &task_b, 0, NULL, 4, SMALL_STACK_SIZE);
  execi( &task1, 0, NULL, 3, SMALL_STACK_SIZE);
  execi( &task2, 0, NULL, 2, SMALL_STACK_SIZE);
  execi( &task3, 0, NULL, 1, SMALL_STACK_SIZE);
/*
 * Reset clock variables
 */
  setClock(Process_A_x1,0);
  setClock(Process_B_x1,0);
  setClock(PERIODIC_TASKS_x,0);


  execi( &controller, 0, NULL, PRIO_HIGHEST, SMALL_STACK_SIZE);

  cputw(MAKESIG);
  return 0;
}
